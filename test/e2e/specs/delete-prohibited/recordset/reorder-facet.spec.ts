import { test, expect, TestInfo, Page } from '@playwright/test';

// locators
import RecordsetLocators from '@isrd-isi-edu/chaise/test/e2e/locators/recordset';

// utils
import { getCatalogID } from '@isrd-isi-edu/chaise/test/e2e/utils/catalog-utils';
import {
  openRecordsetAndResetFacetState, TestIndividualFacetParams, testIndividualFacet, resetFacetState
} from '@isrd-isi-edu/chaise/test/e2e/utils/recordset-utils';
import { dragAndDropWithScroll } from '@isrd-isi-edu/chaise/test/e2e/utils/page-utils';


const testParams = {
  schema_name: 'faceting',
  table_name: 'main',
  sort: '@sort(id)',
  pageSize: 25,
  totalNumFacets: 23,
  initialState: {
    facetNames: [
      'id', 'int_col', 'float_col', 'date_col', 'timestamp_col', 'text_col',
      'longtext_col', 'markdown_col', 'boolean_col', 'jsonb_col', 'F1',
      'to_name', 'f3 (term)', 'from_name', 'F1 with Term', 'Check Presence Text',
      'F3 Entity', 'F5', 'F5 with filter', 'Outbound1 (using F1)',
      'col_w_column_order_false', 'col_w_column_order', 'col_w_long_values'
    ],
    openFacetIndexes: [0, 1, 11],
    /**
     * this order is generated by pausing the page after the moveFacet function calls and looking at the UI.
     */
    facetNamesAfterReorder: [
      'int_col', 'id', 'jsonb_col', 'timestamp_col', 'float_col', 'text_col',
      'longtext_col', 'markdown_col', 'boolean_col', 'F1', 'date_col',
      'f3 (term)', 'from_name', 'F1 with Term', 'Check Presence Text',
      'F3 Entity', 'to_name', 'F5 with filter', 'Outbound1 (using F1)',
      'col_w_column_order_false', 'col_w_column_order', 'col_w_long_values', 'F5'
    ]
  },
  savedStateWInvalids: {
    storage: [
      { 'name': 'some_invalid_facet_name', 'open': true }, // this is an invalid name.
      { 'name': 'timestamp_col', 'open': false }, { 'name': 'text_col', 'open': false },
      { 'name': 'longtext_col', 'open': true }, { 'name': 'markdown_col', 'open': false }, { 'name': 'id', 'open': false },
      { 'name': 'int_col', 'open': false }, { 'name': 'float_col', 'open': false }, { 'name': 'date_col', 'open': false },
      { 'name': 'RMB', 'open': true }, // this is a valid column but it's not part of the annotation
      { 'name': 'boolean_col', 'open': false }, { 'name': 'jsonb_col', 'open': false },
      { 'name': 'eqK7CNP-yhTDab74BW-7lQ', 'open': false }, { 'name': 'cD8qWek-pEc_of8BUq0kAw', 'open': true },
      { 'name': 'BLzaX0hgTVx7uaLkFXlKsw', 'open': false }, { 'name': 'ebn2okbwlp5O0XoSYfzGiA', 'open': false },
      { 'name': 'rtIZqlhTdgze1YnEizt_Vg', 'open': false }, { 'name': 'text_col_2', 'open': true },
      { 'name': '2LEfnTGwdKB6dv-TLbBSmg', 'open': false }, { 'name': '8onrFoVWlj7BhbQ003jSHg', 'open': false },
      { 'name': 'Z5zkN76i7M1ZC9iGs6kZOQ' }, { 'name': 'cpvZOR762iRCtNVMPFIApg', 'open': true }, { 'name': 'col_w_long_values', 'open': false },
      { 'name': 'col_w_column_order_false', 'open': false }, { 'name': 'col_w_column_order', 'open': false },
      { 'name': 'RCT', 'open': true }, // this is a valid column but it's not part of the annotation
    ],
    facetNames: [
      'timestamp_col', 'text_col', 'longtext_col', 'markdown_col',
      'id', 'int_col', 'float_col', 'date_col', 'boolean_col', 'jsonb_col', 'F1',
      'to_name', 'f3 (term)', 'from_name', 'F1 with Term', 'Check Presence Text',
      'F3 Entity', 'F5', 'F5 with filter', 'Outbound1 (using F1)',
      'col_w_long_values', 'col_w_column_order_false', 'col_w_column_order'
    ],
    openFacets: {
      // id and int_col have preselected filters an will be opened regardless of storage
      indexes: [6, 0, 1, 11, 15, 19],
      names: ['longtext_col', 'id', 'int_col', 'to_name', 'Check Presence Text', 'Outbound1 (using F1)']
    }
  },
  savedStateWMissing: {
    storage: [
      { 'name': 'col_w_column_order', 'open': false }, { 'name': 'col_w_column_order_false', 'open': true },
      { 'name': 'col_w_long_values', 'open': false }, { 'name': 'id', 'open': false }, { 'name': 'rtIZqlhTdgze1YnEizt_Vg', 'open': true }
    ],
    facetNames: [
      'col_w_column_order', 'col_w_column_order_false', 'col_w_long_values', 'id', 'F1 with Term',
      'int_col', 'float_col', 'date_col', 'timestamp_col', 'text_col',
      'longtext_col', 'markdown_col', 'boolean_col', 'jsonb_col', 'F1',
      'to_name', 'f3 (term)', 'from_name', 'Check Presence Text',
      'F3 Entity', 'F5', 'F5 with filter', 'Outbound1 (using F1)',
    ],
    openFacets: {
      // id and int_col have preselected filters an will be opened regardless of storage
      indexes: [20, 0, 14, 1, 11],
      names: ['col_w_column_order_false', 'id', 'F1 with Term', 'int_col', 'to_name']
    }
  }
};

/**
 * since reoderding the facets doesn't change their internal index, we can test the same facets for all cases here.
 * we should make sure we've included at least one type of each facets here.
 */
const facetSelectionParams: TestIndividualFacetParams[] = [
  {
    index: 0,
    name: 'id',
    type: 'choice',
    option: 2,
    filter: 'id3',
    numRows: 1,
    options: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10']
  },
  {
    index: 17,
    name: 'F5',
    type: 'choice',
    option: 2,
    filter: 'F5one',
    numRows: 1,
    options: ['All records with value', 'No value', 'one', 'two'],
    isEntityMode: true
  },
  {
    index: 15,
    name: 'Check Presence Text',
    type: 'check_presence',
    notNullNumRows: 9,
    notNullFilter: 'Check Presence TextAll records with value',
    nullNumRows: 21,
    nullFilter: 'Check Presence TextNo value'
  },
  {
    index: 3,
    name: 'date_col',
    type: 'date',
    listElems: 0,
    invalid: '2013-MM-DD',
    initialMin: '2001-01-01',
    initialMax: '2012-12-12',
    error: 'Please enter a valid date value in YYYY-MM-DD format.',
    range: {
      min: '2002-06-14',
      max: '2007-12-12',
      filter: 'date_col2002-06-14 to 2007-12-12',
      numRows: 5
    },
    justMin: {
      min: '2009-12-14',
      filter: 'date_col≥ 2009-12-14',
      numRows: 3
    },
    justMax: {
      max: '2007-04-18',
      filter: 'date_col≤ 2007-04-18',
      numRows: 14
    }
  },
];

test.describe('Facet reorder feature', () => {
  test.describe.configure({ mode: 'parallel' });

  test('changing the order of facets', async ({ page, baseURL }, testInfo) => {
    const currParams = testParams.initialState;

    // this will close all the facets
    await openRecordsetAndResetFacetState(
      page, getURL(testInfo, baseURL), currParams.facetNames.length, currParams.openFacetIndexes, testParams.pageSize
    )

    await test.step('User should be able to drag and change the order of facets.', async () => {
      await RecordsetLocators.waitForFacets(page);
      await testDisplayedFacets(page, testParams.initialState.facetNames);

      // move facets around
      await moveFacet(page, 0, 2);
      await moveFacet(page, 4, 2);
      await moveFacet(page, 9, 1);
      await moveFacet(page, 3, 7);
      await moveFacet(page, 11, 14);
      await moveFacet(page, 17, 22);

      await testDisplayedFacets(page, testParams.initialState.facetNamesAfterReorder);
    });

    await test.step('interacting with the reordered facets', async () => {
      await testFacetSelection(page, []);
    });

    await test.step('refreshing the page should display the saved order and open state.', async () => {
      await page.reload();
      // int_col and id will always be open
      await testDisplayedFacets(page, testParams.initialState.facetNamesAfterReorder, ['int_col', 'id']);
    });
  });

  test('opening a page where the saved state has extra or invalid facets', async ({ page, baseURL }, testInfo) => {
    const currParams = testParams.savedStateWInvalids;

    await test.step('facets should be displayed based on the stored order and invalid ones should be ignored.', async () => {
      await page.goto(getURL(testInfo, baseURL));
      await changeStoredOrder(page, testInfo, currParams.storage);
      await RecordsetLocators.waitForRecordsetPageReady(page);
      await testDisplayedFacets(page, currParams.facetNames, currParams.openFacets.names);
    });

    await test.step('interacting with the reordered facets', async () => {
      await testFacetSelection(page, currParams.openFacets.indexes);
    });

    await test.step('refreshing the page should display the saved order and open state.', async () => {
      // open a facet since all of them are closed due to the previous test
      await RecordsetLocators.getFacetHeaderButtonById(RecordsetLocators.getFacetById(page, 12), 12).click();
      await page.reload();
      await testDisplayedFacets(page, currParams.facetNames, ['id', 'int_col', 'f3 (term)']);
    });
  });

  test('opening a page where the saved state does not include all the visible facets.', async ({ page, baseURL }, testInfo) => {
    const currParams = testParams.savedStateWMissing;

    await test.step('facets should be displayed based on the stored order and extra visible ones should be added.', async () => {
      await page.goto(getURL(testInfo, baseURL));
      await changeStoredOrder(page, testInfo, testParams.savedStateWMissing.storage);
      await RecordsetLocators.waitForRecordsetPageReady(page);
      await testDisplayedFacets(page, testParams.savedStateWMissing.facetNames, currParams.openFacets.names);
    });

    await test.step('interacting with the reordered facets', async () => {
      await testFacetSelection(page, currParams.openFacets.indexes);
    });

    await test.step('refreshing the page should display the saved order and open state.', async () => {
      await page.reload();
      await testDisplayedFacets(page, currParams.facetNames);
    });
  });

});

/********************** helper functions ************************/

const getURL = (testInfo: TestInfo, baseURL?: string) => {
  return `${baseURL}/recordset/#${getCatalogID(testInfo.project.name)}/${testParams.schema_name}:${testParams.table_name}${testParams.sort}`;
}

const testDisplayedFacets = async (page: Page, facetNames: string[], openFacetNames?: string[]) => {
  await expect.soft(RecordsetLocators.getAllFacets(page)).toHaveCount(facetNames.length);
  await expect.soft(RecordsetLocators.getFacetTitles(page)).toHaveText(facetNames);

  if (openFacetNames) {
    const openedFacets = RecordsetLocators.getOpenFacetTitles(page);
    await expect.soft(openedFacets).toHaveCount(openFacetNames.length);
    await expect.soft(openedFacets).toHaveText(openFacetNames);
  }
}


/**
 * This function will move a facet to the original positon of the destination facet.
 * Since moving the facet will also change the position of all the other facets (including destination facet),
 * in the end the facet might not go exactly where you would expect depending on how tall facets are.
 *
 * so for example if the we have f0, f1, f2, f3, and f4. And assume f0 is open and has 10 items, calling this function with
 * moveFacet(page, 0, 1) might move the f0 to be after f2 (while you might expect that this should just change the position of f0 and f1).
 *
 * NOTE: if we realize that this function is not deterministic, we should move this test to manual testing document.
 */
const moveFacet = async (page: Page, facetIndex: number, destIndex: number) => {
  const source = RecordsetLocators.getFacetMoveIcon(page, facetIndex);
  const target = RecordsetLocators.getFacetMoveIcon(page, destIndex);
  await dragAndDropWithScroll(page, source, target);
}

/**
 * go through the facetSelectionParams and test facet features.
 */
const testFacetSelection = async (page: Page, openedFacetIndexes: number[]) => {
  if (openedFacetIndexes.length > 0) {
    await resetFacetState(page, testParams.totalNumFacets, openedFacetIndexes, testParams.pageSize);
  }

  for await (const [index, params] of facetSelectionParams.entries()) {
    await test.step(`facet: ${params.name},`, async () => {
      await testIndividualFacet(page, testParams.pageSize, testParams.totalNumFacets, params);
    });
  }

}

/**
 * change the local storage value for the order of facets for the main table and refresh the page.
 */
const changeStoredOrder = async (page: Page, testInfo: TestInfo, order: any) => {
  const keyName = `facet-order-${getCatalogID(testInfo.project.name)}_${testParams.schema_name}_${testParams.table_name}`;
  const orderStr = JSON.stringify(order);
  await page.evaluate(({ keyName, orderStr }) => {
    window.localStorage.setItem(keyName, orderStr);
  }, { keyName, orderStr });

  await page.reload();
}
