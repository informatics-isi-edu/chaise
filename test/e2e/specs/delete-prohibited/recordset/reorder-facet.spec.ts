import { test, expect, TestInfo, Page, Locator } from '@playwright/test';

// locators
import RecordsetLocators from '@isrd-isi-edu/chaise/test/e2e/locators/recordset';

// utils
import { changeStoredOrder } from '@isrd-isi-edu/chaise/test/e2e/utils/facet-utils';
import { APP_NAMES } from '@isrd-isi-edu/chaise/test/e2e/utils/constants';
import {
  openRecordsetAndResetFacetState, TestIndividualFacetParams, testIndividualFacet, resetFacetState,
  testDisplayedFacets
} from '@isrd-isi-edu/chaise/test/e2e/utils/recordset-utils';
import { clickNewTabLink, dragAndDropWithScroll, generateChaiseURL } from '@isrd-isi-edu/chaise/test/e2e/utils/page-utils';


const facetMapping = {
  'F1': 'eqK7CNP-yhTDab74BW-7lQ',
  'to_name': 'cD8qWek-pEc_of8BUq0kAw',
  'f3 (term)': 'BLzaX0hgTVx7uaLkFXlKsw',
  'from_name': 'ebn2okbwlp5O0XoSYfzGiA',
  'F1 with Term': 'rtIZqlhTdgze1YnEizt_Vg',
  'F3 Entity': '2LEfnTGwdKB6dv-TLbBSmg',
  'F5': '8onrFoVWlj7BhbQ003jSHg',
  'F5 with filter': 'DZJNLl86zoOj3GBHFcPIvA',
  'Outbound1 (using F1)': 'cpvZOR762iRCtNVMPFIApg',
}

const testParams = {
  schema_name: 'faceting',
  table_name: 'main',
  sort: '@sort(id)',
  pageSize: 25,
  totalNumFacets: 23,
  initialState: {
    facetNames: [
      'id', 'int_col', 'float_col', 'date_col', 'timestamp_col', 'text_col',
      'longtext_col', 'markdown_col', 'boolean_col', 'jsonb_col', 'F1',
      'to_name', 'f3 (term)', 'from_name', 'F1 with Term', 'Check Presence Text',
      'F3 Entity', 'F5', 'F5 with filter', 'Outbound1 (using F1)',
      'col_w_column_order_false', 'col_w_column_order', 'col_w_long_values'
    ],
    openFacetIndexes: [0, 1, 11],
    /**
     * this order is generated by pausing the page after the moveFacet function calls and looking at the UI.
     */
    facetNamesAfterReorder: [
      'int_col', 'id', 'timestamp_col', 'float_col', 'date_col', 'text_col',
      'longtext_col', 'markdown_col', 'boolean_col', 'jsonb_col', 'F1',
      'f3 (term)', 'from_name', 'to_name', 'F1 with Term', 'Check Presence Text',
      'F3 Entity', 'F5', 'F5 with filter', 'Outbound1 (using F1)',
      'col_w_column_order_false', 'col_w_column_order', 'col_w_long_values',
    ],
    facetsToOpenAfterReorder: [4, 10]
  },
  savedStateWInvalids: {
    storage: [
      { 'name': 'some_invalid_facet_name', 'open': true }, // this is an invalid name.
      { 'name': 'timestamp_col', 'open': false }, { 'name': 'text_col', 'open': false },
      { 'name': 'longtext_col', 'open': true }, { 'name': 'markdown_col', 'open': false }, { 'name': 'id', 'open': false },
      { 'name': 'int_col', 'open': false }, { 'name': 'float_col', 'open': false }, { 'name': 'date_col', 'open': false },
      { 'name': 'RMB', 'open': true }, // this is a valid column but it's not part of the annotation
      { 'name': 'boolean_col', 'open': false }, { 'name': 'jsonb_col', 'open': false },
      { 'name': facetMapping['F1'], 'open': false }, { 'name': facetMapping['to_name'], 'open': true },
      { 'name': facetMapping['f3 (term)'], 'open': false }, { 'name': facetMapping['from_name'], 'open': false },
      { 'name': facetMapping['F1 with Term'], 'open': false }, { 'name': 'text_col_2', 'open': true },
      { 'name': facetMapping['F3 Entity'], 'open': false }, { 'name': facetMapping['F5'], 'open': false },
      { 'name': facetMapping['F5 with filter'], 'open': false }, { 'name': facetMapping['Outbound1 (using F1)'], 'open': true },
      { 'name': 'col_w_long_values', 'open': false },
      { 'name': 'col_w_column_order_false', 'open': false }, { 'name': 'col_w_column_order', 'open': false },
      { 'name': 'RCT', 'open': true }, // this is a valid column but it's not part of the annotation
    ],
    facetNames: [
      'timestamp_col', 'text_col', 'longtext_col', 'markdown_col',
      'id', 'int_col', 'float_col', 'date_col', 'boolean_col', 'jsonb_col', 'F1',
      'to_name', 'f3 (term)', 'from_name', 'F1 with Term', 'Check Presence Text',
      'F3 Entity', 'F5', 'F5 with filter', 'Outbound1 (using F1)',
      'col_w_long_values', 'col_w_column_order_false', 'col_w_column_order'
    ],
    openFacets: {
      // id and int_col have preselected filters an will be opened regardless of storage
      indexes: [6, 0, 1, 11, 15, 19],
      names: ['longtext_col', 'id', 'int_col', 'to_name', 'Check Presence Text', 'Outbound1 (using F1)']
    }
  },
  savedStateWMissing: {
    storage: [
      { 'name': 'col_w_column_order', 'open': false }, { 'name': 'col_w_column_order_false', 'open': true },
      { 'name': 'col_w_long_values', 'open': false }, { 'name': 'id', 'open': false }, { 'name': 'rtIZqlhTdgze1YnEizt_Vg', 'open': true }
    ],
    facetNames: [
      'col_w_column_order', 'col_w_column_order_false', 'col_w_long_values', 'id', 'F1 with Term',
      'int_col', 'float_col', 'date_col', 'timestamp_col', 'text_col',
      'longtext_col', 'markdown_col', 'boolean_col', 'jsonb_col', 'F1',
      'to_name', 'f3 (term)', 'from_name', 'Check Presence Text',
      'F3 Entity', 'F5', 'F5 with filter', 'Outbound1 (using F1)',
    ],
    openFacets: {
      // id and int_col have preselected filters an will be opened regardless of storage
      indexes: [20, 0, 14, 1, 11],
      names: ['col_w_column_order_false', 'id', 'F1 with Term', 'int_col', 'to_name']
    }
  }
};

/**
 * since reoderding the facets doesn't change their internal index, we can test the same facets for all cases here.
 * we should make sure we've included at least one type of each facets here.
 */
const facetSelectionParams: TestIndividualFacetParams[] = [
  {
    index: 0,
    name: 'id',
    type: 'choice',
    option: 2,
    filter: 'id3',
    numRows: 1,
    options: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10']
  },
  {
    index: 17,
    name: 'F5',
    type: 'choice',
    option: 2,
    filter: 'F5one',
    numRows: 1,
    options: ['All records with value', 'No value', 'one', 'two'],
    isEntityMode: true
  },
  {
    index: 15,
    name: 'Check Presence Text',
    type: 'check_presence',
    notNullNumRows: 9,
    notNullFilter: 'Check Presence TextAll records with value',
    nullNumRows: 21,
    nullFilter: 'Check Presence TextNo value'
  },
  {
    index: 3,
    name: 'date_col',
    type: 'date',
    listElems: 0,
    invalid: '2013-MM-DD',
    initialMin: '2001-01-01',
    initialMax: '2012-12-12',
    error: 'Please enter a valid date value in YYYY-MM-DD format.',
    range: {
      min: '2002-06-14',
      max: '2007-12-12',
      filter: 'date_col2002-06-14 to 2007-12-12',
      numRows: 5
    },
    justMin: {
      min: '2009-12-14',
      filter: 'date_col≥ 2009-12-14',
      numRows: 3
    },
    justMax: {
      max: '2007-04-18',
      filter: 'date_col≤ 2007-04-18',
      numRows: 14
    }
  },
];

test.describe('Reorder facets', () => {
  test.describe.configure({ mode: 'parallel' });

  test('changing the order of facets', async ({ page, baseURL }, testInfo) => {
    const currParams = testParams.initialState;
    const menuBtn = RecordsetLocators.getSidePanelHeadingMenu(page);
    const saveBtn = RecordsetLocators.getSaveFacetOrderBtn(page);
    const applyDefaultBtn = RecordsetLocators.getShowDefaultFacetOrderBtn(page);
    const applySavedBtn = RecordsetLocators.getApplySavedFacetOrderBtn(page);

    // this will close all the facets
    await openRecordsetAndResetFacetState(
      page, getURL(testInfo, baseURL), currParams.facetNames.length, currParams.openFacetIndexes, testParams.pageSize
    )

    await test.step('User should be able to drag and change the order of facets.', async () => {
      await RecordsetLocators.waitForFacets(page);
      await testDisplayedFacets(page, testParams.initialState.facetNames);

      // move facets around
      await moveFacet(page, 0, 2);
      await moveFacet(page, 4, 2);
      await moveFacet(page, 11, 14);

      await testDisplayedFacets(page, testParams.initialState.facetNamesAfterReorder);
    });

    await test.step('interacting with the reordered facets', async () => {
      // test facet selection
      await testFacetSelection(page, []);

      // open some of the facets
      for await (const facetId of testParams.initialState.facetsToOpenAfterReorder) {
        const facet = RecordsetLocators.getFacetById(page, facetId);
        await RecordsetLocators.getFacetHeaderButtonById(facet, facetId).click();
      }
    });

    await test.step('the Save button should be available and clicking on it should save the order.', async () => {
      await testMenuBtnIndicator(menuBtn, true);
      await menuBtn.click();

      await testMenuBtnDisabled(saveBtn, false);
      await testMenuBtnDisabled(applyDefaultBtn, false);
      await testMenuBtnDisabled(applySavedBtn, true);
      await saveBtn.click();

      await testMenuBtnIndicator(menuBtn, false);
      await testDisplayedFacets(page, testParams.initialState.facetNamesAfterReorder, ['timestamp_col', 'F1']);
    });

    await test.step('clicking on "Reset to default" should display the default order.', async () => {
      await menuBtn.click();
      await testMenuBtnDisabled(saveBtn, true);
      await testMenuBtnDisabled(applyDefaultBtn, false);
      await testMenuBtnDisabled(applySavedBtn, true);
      await applyDefaultBtn.click();

      await testMenuBtnIndicator(menuBtn, true);
      await testDisplayedFacets(page, testParams.initialState.facetNames, ['to_name']);
    });

    await test.step('clicking on "Apply saved state" should display the saved state.', async () => {
      await menuBtn.click();
      await testMenuBtnDisabled(saveBtn, false);
      await testMenuBtnDisabled(applyDefaultBtn, true);
      await testMenuBtnDisabled(applySavedBtn, false)
      await applySavedBtn.click();

      await testMenuBtnIndicator(menuBtn, false);
      await testDisplayedFacets(page, testParams.initialState.facetNamesAfterReorder, ['timestamp_col', 'F1']);
    });

    await test.step('refreshing the page should display the saved order and open state.', async () => {
      await page.reload();
      // id and int have filters so they will be opened anyways
      await RecordsetLocators.waitForRecordsetPageReady(page);
      await testDisplayedFacets(page, testParams.initialState.facetNamesAfterReorder, ['int_col', 'id', 'timestamp_col', 'F1']);
    });

    await test.step('changing the order of facets without clicking on save should not save the order.', async () => {
      await moveFacet(page, 0, 2);
      await page.reload();
      await RecordsetLocators.waitForRecordsetPageReady(page);
      await testDisplayedFacets(page, testParams.initialState.facetNamesAfterReorder, ['int_col', 'id', 'timestamp_col', 'F1']);
    });

    await test.step('"Help" option should navigate to the help page.', async () => {
      await menuBtn.click();
      const newPage = await clickNewTabLink(RecordsetLocators.getSidePanelHeadingMenuHelpBtn(page));
      await newPage.waitForURL('**/help/?page=chaise%2Ffacet-panel');
      await newPage.close();
    });

  });

  test('opening a page where the saved state has extra or invalid facets', async ({ page, baseURL }, testInfo) => {
    const currParams = testParams.savedStateWInvalids;

    await test.step('facets should be displayed based on the stored order and invalid ones should be ignored.', async () => {
      await page.goto(getURL(testInfo, baseURL));
      await changeStoredOrder(page, testInfo, testParams.schema_name, testParams.table_name, currParams.storage);
      await RecordsetLocators.waitForRecordsetPageReady(page);
      await testDisplayedFacets(page, currParams.facetNames, currParams.openFacets.names);
    });

    await test.step('interacting with the reordered facets', async () => {
      await testFacetSelection(page, currParams.openFacets.indexes);
    });

    await test.step('refreshing the page should display the saved order and open state.', async () => {
      // open a facet since all of them are closed due to the previous test
      await RecordsetLocators.getFacetHeaderButtonById(RecordsetLocators.getFacetById(page, 12), 12).click();
      await page.reload();
      await testDisplayedFacets(page, currParams.facetNames, currParams.openFacets.names);
    });
  });

  test('opening a page where the saved state does not include all the visible facets.', async ({ page, baseURL }, testInfo) => {
    const currParams = testParams.savedStateWMissing;

    await test.step('facets should be displayed based on the stored order and extra visible ones should be added.', async () => {
      await page.goto(getURL(testInfo, baseURL));
      await changeStoredOrder(page, testInfo, testParams.schema_name, testParams.table_name, testParams.savedStateWMissing.storage);
      await RecordsetLocators.waitForRecordsetPageReady(page);
      await testDisplayedFacets(page, testParams.savedStateWMissing.facetNames, currParams.openFacets.names);
    });

    await test.step('interacting with the reordered facets', async () => {
      await testFacetSelection(page, currParams.openFacets.indexes);
    });

    await test.step('refreshing the page should display the saved order and open state.', async () => {
      await page.reload();
      await testDisplayedFacets(page, currParams.facetNames, currParams.openFacets.names);
    });
  });

});

/********************** helper functions ************************/

const getURL = (testInfo: TestInfo, baseURL?: string) => {
  return generateChaiseURL(APP_NAMES.RECORDSET, testParams.schema_name, testParams.table_name,testInfo, baseURL) + testParams.sort;
}

/**
 * This function will move a facet to the original positon of the destination facet.
 * Since moving the facet will also change the position of all the other facets (including destination facet),
 * in the end the facet might not go exactly where you would expect depending on how tall facets are.
 *
 * so for example if the we have f0, f1, f2, f3, and f4. And assume f0 is open and has 10 items, calling this function with
 * moveFacet(page, 0, 1) might move the f0 to be after f2 (while you might expect that this should just change the position of f0 and f1).
 *
 * NOTE: if we realize that this function is not deterministic, we should move this test to manual testing document.
 */
const moveFacet = async (page: Page, facetIndex: number, destIndex: number) => {
  const source = RecordsetLocators.getFacetMoveIcon(page, facetIndex);
  const target = RecordsetLocators.getFacetMoveIcon(page, destIndex);
  await dragAndDropWithScroll(page, source, target);
}

/**
 * go through the facetSelectionParams and test facet features.
 */
const testFacetSelection = async (page: Page, openedFacetIndexes: number[]) => {
  if (openedFacetIndexes.length > 0) {
    await resetFacetState(page, testParams.totalNumFacets, openedFacetIndexes, testParams.pageSize);
  }

  for await (const [index, params] of facetSelectionParams.entries()) {
    await test.step(`facet: ${params.name},`, async () => {
      await testIndividualFacet(page, testParams.pageSize, testParams.totalNumFacets, params);
    });
  }

}

const testMenuBtnDisabled = async (locator: Locator, disabled: boolean) => {
  await expect.soft(locator).toBeVisible();
  if (disabled) {
    await expect.soft(locator).toContainClass('disabled');
  } else {
    await expect.soft(locator).not.toContainClass('disabled');
  }
}

const testMenuBtnIndicator = async (locator: Locator, hasIndicator: boolean) => {
  await expect.soft(locator).toBeVisible();
  if (hasIndicator) {
    await expect.soft(locator).toContainClass('chaise-btn-with-indicator');
  } else {
    await expect.soft(locator).not.toContainClass('chaise-btn-with-indicator');
  }
}
